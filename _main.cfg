#ifdef MULTIPLAYER

[modification]
    id=dwarftough_Biased_RNG_in_MP
    name=_"Biased RNG in MP"
    description=_"Since 1.16 the Biased RNG has been available in SP. It makes the outcomes of battles follow the expected value much more closely drastically reducing the variance. Choosing a different RNG is not supported in Multiplayer, so this mod tries to emulate the Biased RNG behaviour.
    
It's almost certainly incompatible with Advanced Wesnoth Wars and it's very possible more addons incompatible with this. Make sure to leave bugreports on the forums!

Summary how it works: it calculates the expected value, with is EV = strikes * chance to hit. If it's an integer, the unit hits exactly EV times. If it has a fractional part x, then the unit hits floor(EV) times and may make one extra hit with probability fractional_part(EV). The order of hits and misses is still random. For example: Mage has 3 attacks with 70% to hit. EV = 3 * 0.7 = 2.1. So Mage will hit two times surely and with probability 10% one more time."
    type=mp
    require_modification=no
    [lua]
        code = <<
function find_weapon_index(unit, weapon)
	local attack_idx = 0
	for idx, tag in ipairs(unit) do
		if tag[1] == 'attack' then
			attack_idx = attack_idx + 1
			local atk_data = tag[2]
			if atk_data.name == weapon.name and atk_data.range == weapon.range and atk_data.type == weapon.type and
			 atk_data.number == weapon.number and atk_data.damage == weapon.damage then
				return attack_idx
			end
		end
	end
	return 0
end

local function gen_hits_from_mean(mean, blows)
    if blows == 0 then
        return {}
    end
    local hits = math.floor(mean)
	local diff = mean - hits
	if diff >= 0.01 then
		if mathx.random(100) <= diff * 100 then
			hits = hits + 1
		end
	end
	local hit_seq = {}
	for i=1,blows do
		table.insert(hit_seq, {hits = i <= hits})
	end
	mathx.shuffle(hit_seq)
	return hit_seq
end

local function generate_hits(varName, we)
    if we.num_blows == nil or math.floor(we.num_blows) == 0 then
        return
    end
	local mean = we.chance_to_hit * we.num_blows / 100.0
	----print(varName)
	----print(tostring(we.chance_to_hit))
	----print(tostring(math.floor(we.num_blows)))
	----print(tostring(mean))
	wml.array_access.set(varName, gen_hits_from_mean(mean,math.floor(we.num_blows)))
	wml.variables[varName .. "_mean"] = mean
	wml.variables[varName .. "_blows"] = math.floor(we.num_blows)
end

---- needed for bers
function reshuffle_previous_simulation(varName)
    if (not wml.variables[varName .. "_blows"]) or (wml.variables[varName .. "_blows"] == 0) then
        return
    end
    wml.array_access.set(varName, gen_hits_from_mean(wml.variables[varName .. "_mean"], wml.variables[varName .. "_blows"]))
end

--- for berserk we MUST NOT repeat the simulation after attack started because chances to hit will be 0 or 100
--- with our objects. We need to either remove them before simulating or just copy from backup
function simulate_and_generate(forAttacker, forDefender)
	local unit, second_unit, weapon, second_weapon = wml.variables["unit"], wml.variables["second_unit"], wml.variables["weapon"], wml.variables["second_weapon"]
	local widx = find_weapon_index(unit, weapon)
	if widx == 0 then
		return false ---- something went wrong, didn't find the attacker's weapon
	end
	local swidx = 0
	if second_weapon.number ~= nil and second_weapon.name ~= "none" then
		swidx = find_weapon_index(second_unit, second_weapon)
		if swidx == 0 then
			return false ---- here we should've found second weapon
		end
	end
	local awe, dwe
	local unit, second_unit = wesnoth.units.get(unit.x, unit.y), wesnoth.units.get(second_unit.x, second_unit.y) -- convert from table to lua unit type
	if swidx ~= 0 then
		_, _, awe, dwe = wesnoth.simulate_combat(unit, widx, second_unit, swidx)
	else
		_, _, awe, _ = wesnoth.simulate_combat(unit, widx, second_unit)
	end
	if forAttacker then
		generate_hits("biased_rng_attacker_seq", awe)
	end
	if forDefender and dwe ~= nil then
		generate_hits("biased_rng_defender_seq", dwe)
	end
	return true
end      
>>
    [/lua]
#define BIASED_RNG_CLEANUP_VARS UNITVAR SEQVAR
        {CLEAR_VARIABLE {SEQVAR}}
        {CLEAR_VARIABLE {SEQVAR}_mean}
        {CLEAR_VARIABLE {SEQVAR}_blows}
        {CLEAR_VARIABLE {UNITVAR}.variables.biased_rng_must_hit}
        {CLEAR_VARIABLE {UNITVAR}.variables.biased_rng_must_miss}
#enddef
#define BIASED_RNG_SET_CURRENT_HIT_OR_MISS UNITVAR SEQVAR
[if]
    [variable]
        name={SEQVAR}.length
        numerical_not_equals=0
    [/variable]
    [then]
        [if]
            [variable]
                name={SEQVAR}[0].hits
                boolean_equals=yes
            [/variable]
            [then]
                {VARIABLE {UNITVAR}.variables.biased_rng_must_hit yes}
                {VARIABLE {UNITVAR}.variables.biased_rng_must_miss no}
            [/then]
            [else]
                {VARIABLE {UNITVAR}.variables.biased_rng_must_hit no}
                {VARIABLE {UNITVAR}.variables.biased_rng_must_miss yes}
            [/else]
        [/if]
        {CLEAR_VARIABLE {SEQVAR}[0]}
        #[unstore_unit]
        #    variable={UNITVAR}
        #[/unstore_unit]
        # use unstore after this!
    [/then]
[/if]
#enddef    
#define BIASED_RNG_HIT_MISS_EVENT UNITVAR SEQVAR
        {CLEAR_VARIABLE {UNITVAR}.variables.biased_rng_must_hit}
        {CLEAR_VARIABLE {UNITVAR}.variables.biased_rng_must_miss}
        [if] # we need to try generate new table for the case of berserk
            [variable]
                name={SEQVAR}.length
                numerical_equals=0
            [/variable]
            [then]
                [lua]
                [args]
                    var = {SEQVAR}
                [/args]
        	code = <<local t = ...;
        	reshuffle_previous_simulation(t.var)>>
        [/lua]
            [/then]
        [/if]
        {BIASED_RNG_SET_CURRENT_HIT_OR_MISS {UNITVAR} {SEQVAR}}
        [unstore_unit]
            variable={UNITVAR}
        [/unstore_unit]
#enddef
    [event]
        name=attack
        first_time_only=no
        {BIASED_RNG_CLEANUP_VARS unit biased_rng_attacker_seq}
        {BIASED_RNG_CLEANUP_VARS second_unit biased_rng_defender_seq}
        [lua]
        	code = <<
        	 simulate_and_generate(true, true)
        	>>
        [/lua]
        # unstores here
        {BIASED_RNG_SET_CURRENT_HIT_OR_MISS unit biased_rng_attacker_seq}
        {BIASED_RNG_SET_CURRENT_HIT_OR_MISS second_unit biased_rng_defender_seq}
        [unstore_unit]
            variable=unit
        [/unstore_unit]
        [unstore_unit]
            variable=second_unit
        [/unstore_unit]
    [/event]
    [event]
        name=attack end
        first_time_only=no
        {BIASED_RNG_CLEANUP_VARS unit biased_rng_attacker_seq}
        {BIASED_RNG_CLEANUP_VARS second_unit biased_rng_defender_seq}
        [unstore_unit]
            variable=unit
        [/unstore_unit]
        [unstore_unit]
            variable=second_unit
        [/unstore_unit]
    [/event]
    [event]
        name=attacker hits, attacker misses
        first_time_only=no
        {BIASED_RNG_HIT_MISS_EVENT unit biased_rng_attacker_seq}
    [/event]
    [event]
        name=defender hits, defender misses
        first_time_only=no
        {BIASED_RNG_HIT_MISS_EVENT second_unit biased_rng_defender_seq}
    [/event]
    [event]
        name=unit placed
        first_time_only=no
        [filter]
            [not]
                ability=biased_rng_hit
            [/not]
        [/filter]
        [object]
            id=biased_rng_hit
            [filter]
                id=$unit.id
            [/filter]
            silent=yes
            duration=forever
            take_only_once=no
            [effect]
                apply_to=new_ability
                [abilities]
                    [chance_to_hit]
                        id=biased_rng_hit
                        value=100
                        cumulative=no
                        affect_self=yes
                        overwrite_specials=both_sides
                        [overwrite]
                            priority=1000
                        [/overwrite]
                        [filter_self]
                                [filter_wml]
                                    [variables]
                                        biased_rng_must_hit=yes
                                    [/variables]
                                [/filter_wml]
                        [/filter_self]
                    [/chance_to_hit]
                [/abilities]
            [/effect]
        [/object]
    [/event]
    [event]
        name=unit placed
        first_time_only=no
        [filter]
            [not]
                ability=biased_rng_miss
            [/not]
        [/filter]
        [object]
            id=biased_rng_miss
            [filter]
                id=$unit.id
            [/filter]
            silent=yes
            duration=forever
            take_only_once=no
            [effect]
                apply_to=new_ability
                [abilities]
                    [chance_to_hit]
                        id=biased_rng_miss
                        value=0
                        cumulative=no
                        affect_self=yes
                        overwrite_specials=both_sides
                        [overwrite]
                            priority=1000
                        [/overwrite]
                        [filter_self]
                                [filter_wml]
                                    [variables]
                                        biased_rng_must_miss=yes
                                    [/variables]
                                [/filter_wml]
                        [/filter_self]
                    [/chance_to_hit]
                [/abilities]
            [/effect]
        [/object]
    [/event]
    [event]
        name=turn 1
        [chat]
            speaker="Biased RNG"
            message="Version 1.0.0"
        [/chat]
    [/event]
[/modification]
#endif
